## ---------------------------
## Script name: VIRAL TRACK: Viral_Scanning: Module 3 - SAMTOOLS EXTRACTING VIRAL BAM
## Function: Map Single Cell Virals from individual FASTQ file using STAR.
## Author: Pierre Bost (as used in Viral TRACK paper). Updated by Lauren Overend (LEO)
##
## Date Created: 2020 - June 
##
## Email: lauren.overend@oriel.ox.ac.uk
##
## ---------------------------
##
## Notes:
##   
##
## ---------------------------
if(nzchar(system.file(package = "optparse"))==FALSE){
  stop("optparse not installed. Terminating. \n")
}
suppressMessages(library(optparse))
parser <- OptionParser()
option_list <- list( 
  make_option(c("-n", "--nThreadmap"), action="store", default=8, type="integer", help="runThreadN for Star Mapping [default]"),
  make_option(c("-o", "--outputdir"), action="store", default='/well/immune-rep/users/kvi236/VIRUS/TEST', type="character", help="Path to output directory"),
  make_option(c("-i", "--indexgenome"), action="store", type="character", default="/well/immune-rep/users/kvi236/VIRAL_TRACK_REFERENCE_COVID/", help="Path to VIRAL TRACK reference genome [default]"),
  make_option(c("-s", "--nThreadsort"), action="store", type="integer", default=1, help="outBAMsortingThreadN for STAR Mapping [default] - usually < runThreadN"),
  make_option(c("-m", "--minreads"), action="store", type="integer", default=50, help="Minimum number of mapped viral reads [default]"),
  make_option(c("-b", "--bins"), action="store", type="integer", default=60, help="outBAMsortingBinsN for STAR Mapping [default]"),
  make_option(c("-f", "--fastq"), action="store", type="character", default = '/well/immune-rep/shared/10X_GENOMICS/EBV_LCLS/FASTQ/SRR8427168/DOWNSAMPLES/sub10k.fa', help="Path to input FASTQ file [default]"),
  make_option(c("-r", "--runname"), action="store", type="character", default="Viral_Track", help="Run Name [default]"),
  make_option(c("-v", "--viralannotation"), action="store", type="character", default="/well/immune-rep/users/kvi236/VIRUS/VIRAL_TRACK/Virusite_annotation_file.txt", help="Path to VirusSite annotation file [default]")
)

opt_parser = OptionParser(option_list=option_list);
opt = parse_args(opt_parser, print_help_and_exit = TRUE, args = commandArgs(trailingOnly = TRUE) )

if (is.null(opt$fastq)){
  stop("No FASTq file provided. Terminating. \n", call.=FALSE)
}
if (is.null(opt$outputdir)){
  stop("Output directory not present: must be specified. Terminating. \n", call.=FALSE)
}
if (opt$runname == "Viral_Track"){
  warning("Using Default Run-Name: Reconsider using Custom Run-Name. \n")
}
if (!dir.exists(opt$outputdir)) {
  warning("Output directory does not exist! Creating it! \n")
  dir.create(opt$outputdir)
}
if (!is.numeric(opt$nThreadmap) | opt$nThreadmap < 1 ) {
  stop("STAR Mapping Threads are Incorrect. Terminating. \n")
}
if (!is.numeric(opt$nThreadsort)) {
  stop("STAR BAM Sorting Threads are incorrect. Terminating. \n")
}
if (opt$nThreadsort > 1 ) {
  warning("STAR BAM Sorting Threads are higher than recommended (Default: 1). Consider adjusting paramaters.  \n")
}
if (!dir.exists(opt$indexgenome)) {
  stop("Index Genome Directory Does Not Exist. Terminating. \n")
}
if (!file.exists(opt$viralannotation)) {
  stop("VirusSite Database File Does Not Exist. Terminating. \n")
}

if (opt$nThreadmap >= round(0.8*detectCores(),0) ) {
  stop("Not enough threads available. Terminating. \n")
}
if (opt$nThreadsort > opt$nThreadmap ) {
  warning("Bam Sorting Threads exceeds Bam Mapping Threads. May be incompatible with memory request. \n")
}

## Check all packages are installed. 
if(nzchar(system.file(package = "Biostrings"))==FALSE){
  stop("Biostrings not installed. Terminating. \n")
} 
if(nzchar(system.file(package = "ShortRead"))==FALSE){
  stop("ShortRead not installed. Terminating. \n")
}
if(nzchar(system.file(package = "doParallel"))==FALSE){
  stop("doParallel not installed. Terminating. \n")
}
if(nzchar(system.file(package = "GenomicAlignments"))==FALSE){
  stop("GenomicAlignments not installed. Terminating. \n")
}

## Check validity of FASTQ File
List_target_path = c()
if (!is.null(opt$fastq)) {
  if(file.exists(opt$fastq)){
    cat("FATSQ File present. \n") 
    if(any(grepl(".fa|.fq|.fasta", opt$fastq))==TRUE){
      cat("FASTQ File Type is Valid. \n")
      List_target_path = opt$fastq
    } else {
      stop("Fastq File Provided is Not of Type '.fasta/.fq/.fa'. Terminating. \n")
    }
  } else {
    stop("FASTQ provided but Path is Invalid. Terminating. \n")
  }
} else {
  stop("No FASTQ File Provided. Terminating. \n")
}

## Load Required Libraries
suppressMessages(library(Biostrings))
suppressMessages(library(ShortRead))
suppressMessages(library(doParallel))
suppressMessages(library(GenomicAlignments))

## Setting up log.file: 
log <-  paste0(opt$outputdir, "/ViralTrack_Scanning_Module1_", opt$fastq, ".log")

## Checking the parameters values
cat("ViralTrack_Scanning.2.0 by Lauren Overend & Pierre Bost \n", file=log, append=TRUE)
cat(paste0("Run Name: ", opt$runname, "\n"), file=log, append=TRUE)
start_time <- Sys.time()
cat(paste0("Start time: ", start_time, "\n"), file=log, append=TRUE)
cat(paste0("Output directory: ", opt$outputdir, "\n"), file=log, append=TRUE)
cat(paste0("FASTQ File: ", opt$fastq, "\n"), file=log, append=TRUE)
cat("----------------------------------------------\n", file=log, append=TRUE)
cat("Input Parameters Read and Validated. Commencing Viral Track. \n", file=log, append = TRUE)
##--------------------------------------------------------------


## Renaming Paramaters to original variable names as in ViralTrack1.0
N_thread = opt$nThreadmap 
N_thread_sort = opt$nThreadsort
N_bins = opt$bins
Output_directory = opt$outputdir 
Name_run = opt$runname    
Index_genome = opt$indexgenome 
Minimal_read_mapped = as.numeric(opt$minreads)
Viral_annotation_file = opt$viralannotation
name_target = unlist(base::strsplit(List_target_path,"/",fixed = T))
name_target = name_target[length(name_target)]
name_target = gsub('/','',name_target)
is_gz_file = any(grepl(pattern = ".gz",name_target))
name_target = gsub('.fastq|.fa|.fq|.gz','',name_target)   #Cleaning the name to get the original Amplification batch number
temp_output_dir = paste(Output_directory, "/", name_target,sep = "")
name_prefix = paste0(temp_output_dir, "/", name_target)
name_prefix = paste0(temp_output_dir, "/", name_target)
temp_sorted_bam = paste0(name_prefix, "Aligned.sortedByCoord.out.bam")
## ----------------------------------------------------------------------
## Input File
temp_chromosome_count_path = paste(temp_output_dir,"/Count_chromosomes.txt",sep = "")
## ---------------------------------------------------------------------------------------------------------------

cat('Setting up parallel environment \n', file="Viral_track_scanning.log", append = TRUE)
cl =makeCluster(N_thread)
registerDoParallel(cl)
cat('Done \n', file="Viral_track_scanning.log", append = TRUE)

##We load it and clean it to remove non mapped viruses
temp_chromosome_count = read.table(temp_chromosome_count_path,header = F,row.names = 1)
colnames(temp_chromosome_count) = c("Chromosome_length","Mapped_reads","Unknown")
##Let's filter this table : removing host/human sequences and viruses with less than a given threshold of reads
Chromosome_to_remove = c("X","Y","MT",as.character(1:23))
Chromosome_to_remove = c("1","10","11","12","13","14","15","16","17","18","19","2","20","21","22","3","4","5","6","7","8","9","MT","X","Y","
                          KI270728.1","KI270727.1","KI270442.1","KI270729.1","GL000225.1","KI270743.1","GL000008.2","GL000009.2,
                          KI270747.1","KI270722.1","GL000194.1","KI270742.1","GL000205.2","GL000195.1","KI270736.1","KI270733.1","
                          GL000224.1","GL000219.1","KI270719.1","GL000216.2","KI270712.1","KI270706.1","KI270725.1","KI270744.1","
                          KI270734.1","GL000213.1","GL000220.1","KI270715.1","GL000218.1","KI270749.1","KI270741.1","GL000221.1","
                          KI270716.1","KI270731.1","KI270751.1","KI270750.1","KI270519.1","GL000214.1","KI270708.1","KI270730.1,
                          KI270438.1","KI270737.1","KI270721.1","KI270738.1","KI270748.1","KI270435.1","GL000208.1","KI270538.1,
                          KI270756.1","KI270739.1","KI270757.1","KI270709.1","KI270746.1","KI270753.1","KI270589.1","KI270726.1,
                          KI270735.1","KI270711.1","KI270745.1","KI270714.1","KI270732.1","KI270713.1","KI270754.1","KI270710.1,
                          KI270717.1","KI270724.1","KI270720.1","KI270723.1","KI270718.1","KI270317.1","KI270740.1","KI270755.1","
                          KI270707.1","KI270579.1","KI270752.1","KI270512.1","KI270322.1","GL000226.1","KI270311.1","KI270366.1,
                          KI270511.1","KI270448.1","KI270521.1","KI270581.1","KI270582.1","KI270515.1","KI270588.1","KI270591.1","
                          KI270522.1","KI270507.1","KI270590.1","KI270584.1","KI270320.1","KI270382.1","KI270468.1","KI270467.1,
                          KI270362.1","KI270517.1","KI270593.1","KI270528.1","KI270587.1","KI270364.1","KI270371.1","KI270333.1,
                          KI270374.1","KI270411.1","KI270414.1","KI270510.1","KI270390.1","KI270375.1","KI270420.1","KI270509.1,
                          KI270315.1","KI270302.1","KI270518.1","KI270530.1","KI270304.1","KI270418.1","KI270424.1","KI270417.1,
                          KI270508.1","KI270303.1","KI270381.1","KI270529.1","KI270425.1","KI270396.1","KI270363.1","KI270386.1,
                          KI270465.1","KI270383.1","KI270384.1","KI270330.1","KI270372.1","KI270548.1","KI270580.1","KI270387.1,
                          KI270391.1","KI270305.1","KI270373.1","KI270422.1","KI270316.1","KI270340.1","KI270338.1","KI270583.1,
                          KI270334.1","KI270429.1","KI270393.1","KI270516.1","KI270389.1","KI270466.1","KI270388.1","KI270544.1,
                          KI270310.1","KI270412.1","KI270395.1","KI270376.1","KI270337.1","KI270335.1","KI270378.1","KI270379.1,
                        KI270329.1","KI270419.1","KI270336.1","KI270312.1","KI270539.1","KI270385.1","KI270423.1","KI270392.1","KI270394.1")
temp_chromosome_count = temp_chromosome_count[!rownames(temp_chromosome_count)%in%Chromosome_to_remove,] ##All viral "chromosome start with a "NC"
temp_chromosome_count = temp_chromosome_count[temp_chromosome_count$Mapped_reads>Minimal_read_mapped,]
cat("Calculated temp_chromosome_count", file=log, append = TRUE)

##We now need to check the quality of the mapping for each virus
cat("Checking the mapping quality of each virus... \n", file="Viral_track_scanning.log", append = TRUE)
#We first create a sub-directory to export the sam files corresponding to each virus
dir.create(paste(temp_output_dir,"/Viral_BAM_files",sep = "")) 

#We then create one SAM file for each virus 
if(length(rownames(temp_chromosome_count))>1){
  foreach(i=rownames(temp_chromosome_count)) %dopar% {
    temp_export_bam_command = paste("samtools view -b ",temp_sorted_bam," \'",i,"\'"," > \'",temp_output_dir,"/Viral_BAM_files/",i,".bam\'",sep = "")
    system(temp_export_bam_command)
  }
}

cat("Extracting human counts and filtering", file="Viral_track_scanning.log", append = TRUE)
temp_chromosome_count_2 = read.table(temp_chromosome_count_path,header = F,row.names = 1)
colnames(temp_chromosome_count_2) = c("Chromosome_length","Mapped_reads","Unknown")
Human_chr = c("X","Y","MT",as.character(1:23)) 
temp_chromosome_count_2 = temp_chromosome_count_2[rownames(temp_chromosome_count_2)%in%Human_chr,]
temp_chromosome_count_2 = temp_chromosome_count_2[temp_chromosome_count_2$Mapped_reads>Minimal_read_mapped,]
dir.create(paste(temp_output_dir,"/HUMAN_BAM_files",sep = ""))

foreach(i=rownames(temp_chromosome_count_2)) %dopar% {
  temp_export_bam_command = paste("samtools view -b ",temp_sorted_bam," \'",i,"\'"," > \'",temp_output_dir,"/HUMAN_BAM_files/",i,".bam\'",sep = "")
  system(temp_export_bam_command)
}
cat(paste0("Export of the viral and HUMAN SAM file done for",name_target,"\n"), file="Viral_track_scanning.log", append = TRUE)





